import { print, filesystem, system, prompt } from 'gluegun'
import os from 'os'
import { promisify } from 'util'
import { chmod } from 'fs'
import {
  INSTALL_PATH,
  INSTALL_DIR,
  EXPORTS_FILE_PATH,
  XSBUG_LOG_PATH,
} from './constants'
import upsert from '../patching/upsert'
import {
  downloadReleaseTools,
  fetchRelease,
  MissingReleaseAssetError,
} from './moddable'
import type { PlatformSetupArgs } from './types'

const chmodPromise = promisify(chmod)

export default async function ({
  sourceRepo,
  branch,
  release,
}: PlatformSetupArgs): Promise<void> {
  print.info('Setting up the mac tools!')

  const BIN_PATH = filesystem.resolve(
    INSTALL_PATH,
    'build',
    'bin',
    'mac',
    'release',
  )
  const DEBUG_BIN_PATH = filesystem.resolve(
    INSTALL_PATH,
    'build',
    'bin',
    'mac',
    'debug',
  )
  const BUILD_DIR = filesystem.resolve(
    INSTALL_PATH,
    'build',
    'makefiles',
    'mac',
  )

  // 0. ensure xcode command line tools are available (?)
  try {
    await system.exec('xcode-select -p')
  } catch (error) {
    print.error(
      'Xcode command line tools are required to build the SDK: https://developer.apple.com/xcode/',
    )
    process.exit(1)
  }

  let buildTools = false

  const spinner = print.spin()
  spinner.start('Beginning setup...')

  // 1. clone moddable repo into ./local/share directory if it does not exist yet
  try {
    filesystem.dir(INSTALL_DIR)

    await upsert(EXPORTS_FILE_PATH, `# Generated by xs-dev CLI`)
  } catch (error) {
    spinner.fail(`Error setting up install directory: ${String(error)}`)
    process.exit(1)
  }

  if (filesystem.exists(INSTALL_PATH) !== false) {
    spinner.info('Moddable repo already installed')
  } else {
    try {
      if (release !== undefined && (branch === undefined || branch === null)) {
        spinner.start('Getting latest Moddable-OpenSource/moddable release')
        const remoteRelease = await fetchRelease(release)

        if (remoteRelease.assets.length === 0) {
          spinner.stop()
          print.warning(
            `Moddable release ${release} does not have any pre-built assets.`,
          )
          buildTools = await prompt.confirm(
            'Would you like to continue setting up and build the SDK locally?',
            true,
          )

          if (!buildTools) {
            print.info(
              'Please select another release version with pre-built assets: https://github.com/Moddable-OpenSource/moddable/releases',
            )
            process.exit(0)
          }
          spinner.start()
        }

        await system.spawn(
          `git clone ${sourceRepo} ${INSTALL_PATH} --depth 1 --branch ${remoteRelease.tag_name} --single-branch`,
        )

        if (!buildTools) {
          filesystem.dir(BIN_PATH)
          filesystem.dir(DEBUG_BIN_PATH)

          spinner.info('Downloading release tools')
          try {
            const universalAssetName = `moddable-tools-macuniversal.zip`
            await downloadReleaseTools({
              writePath: BIN_PATH,
              assetName: universalAssetName,
              release: remoteRelease,
            })
          } catch (error: unknown) {
            if (error instanceof MissingReleaseAssetError) {
              const isArm = os.arch() === 'arm64'
              const assetName = isArm
                ? 'moddable-tools-mac64arm.zip'
                : 'moddable-tools-mac64.zip'
              await downloadReleaseTools({
                writePath: BIN_PATH,
                assetName,
                release: remoteRelease,
              })
            } else {
              throw error as Error
            }
          }
          const tools = filesystem.list(BIN_PATH) ?? []
          await Promise.all(
            tools.map(async (tool) => {
              if (tool.endsWith('.app')) {
                const mainPath = filesystem.resolve(
                  BIN_PATH,
                  tool,
                  'Contents',
                  'MacOS',
                  'main',
                )
                await chmodPromise(mainPath, 0o751)
              } else {
                await chmodPromise(filesystem.resolve(BIN_PATH, tool), 0o751)
              }
              await filesystem.copyAsync(
                filesystem.resolve(BIN_PATH, tool),
                filesystem.resolve(DEBUG_BIN_PATH, tool),
              )
            }),
          )
        }
      } else {
        spinner.start(`Cloning ${sourceRepo} repo`)
        await system.spawn(
          `git clone ${sourceRepo} ${INSTALL_PATH} --depth 1 --branch ${branch} --single-branch`,
        )
        buildTools = true
      }
      spinner.succeed()
    } catch (error) {
      spinner.fail(`Error cloning moddable repo: ${String(error)}`)
      process.exit(1)
    }
  }

  // 2. configure MODDABLE env variable, add release binaries dir to PATH
  process.env.MODDABLE = INSTALL_PATH
  process.env.PATH = `${String(process.env.PATH)}:${BIN_PATH}`

  await upsert(EXPORTS_FILE_PATH, `export MODDABLE=${process.env.MODDABLE}`)
  await upsert(EXPORTS_FILE_PATH, `export PATH="${BIN_PATH}:$PATH"`)

  // 3. cd into makefiles dir for platform, run `make`
  if (buildTools) {
    try {
      spinner.start('Building platform tooling')
      await system.exec('make', { cwd: BUILD_DIR, stdout: process.stdout })
      spinner.succeed()
    } catch (error) {
      spinner.fail(`Error building mac tooling: ${String(error)}`)
      process.exit(1)
    }
  }

  // 4. symlink xsbug.app into user applications directory
  try {
    filesystem.symlink(
      filesystem.resolve(BIN_PATH, 'xsbug.app'),
      '/Applications/xsbug.app',
    )
  } catch (error) {
    if (!String(error).includes('exists')) {
      spinner.fail(`Issue creating symlink for xsbug.app: ${String(error)}`)
      process.exit(1)
    } else {
      spinner.info('xsbug.app symlink already exists')
    }
  }

  // 5. install xsbug-log dependencies
  if (system.which('npm') !== null) {
    spinner.start('Installing xsbug-log dependencies')
    await system.exec('npm install', { cwd: XSBUG_LOG_PATH })
    spinner.succeed()
  }

  spinner.succeed(
    'Moddable SDK successfully set up! Start a new terminal session and run the "helloworld example": xs-dev run --example helloworld',
  )
}
