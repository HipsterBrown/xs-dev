import { print, filesystem, system } from 'gluegun'
import os from 'os'
import { promisify } from 'util'
import { chmod } from 'fs'
import {
  INSTALL_PATH,
  INSTALL_DIR,
  EXPORTS_FILE_PATH,
  MODDABLE_REPO,
  XSBUG_LOG_PATH,
  getProfilePath,
} from './constants'
import upsert from '../patching/upsert'
import { downloadReleaseTools, fetchLatestRelease, MissingReleaseAssetError } from './moddable'
import { SetupArgs } from './types'

const chmodPromise = promisify(chmod)

export default async function({ targetBranch }: SetupArgs): Promise<void> {
  print.info('Setting up the mac tools!')

  const BIN_PATH = filesystem.resolve(
    INSTALL_PATH,
    'build',
    'bin',
    'mac',
    'release'
  )
  const DEBUG_BIN_PATH = filesystem.resolve(
    INSTALL_PATH,
    'build',
    'bin',
    'mac',
    'debug'
  )
  const BUILD_DIR = filesystem.resolve(
    INSTALL_PATH,
    'build',
    'makefiles',
    'mac'
  )
  const PROFILE_PATH = getProfilePath()

  // 0. ensure xcode command line tools are available (?)
  try {
    await system.exec('xcode-select -p')
  } catch (error) {
    print.error(
      'Xcode command line tools are required to build the SDK: https://developer.apple.com/xcode/'
    )
    process.exit(1)
  }

  const spinner = print.spin()
  spinner.start('Beginning setup...')

  // 1. clone moddable repo into ./local/share directory if it does not exist yet
  try {
    filesystem.dir(INSTALL_DIR)

    await upsert(EXPORTS_FILE_PATH, `# Generated by xs-dev CLI`)
  } catch (error) {
    spinner.fail(`Error setting up install directory: ${String(error)}`)
    process.exit(1)
  }

  if (filesystem.exists(INSTALL_PATH) !== false) {
    spinner.info('Moddable repo already installed')
  } else {
    try {
      if (targetBranch === 'latest-release') {
        spinner.start('Getting latest Moddable-OpenSource/moddable release')
        const release = await fetchLatestRelease()
        await system.spawn(
          `git clone ${MODDABLE_REPO} ${INSTALL_PATH} --depth 1 --branch ${release.tag_name} --single-branch`
        )

        filesystem.dir(BIN_PATH)
        filesystem.dir(DEBUG_BIN_PATH)

        spinner.info('Downloading release tools')
        try {
          const universalAssetName = `moddable-tools-macuniversal.zip`
          await downloadReleaseTools({
            writePath: BIN_PATH,
            assetName: universalAssetName,
            release,
          })
        } catch (error: unknown) {
          if (error instanceof MissingReleaseAssetError) {
            const isArm = os.arch() === 'arm64'
            const assetName = isArm
              ? 'moddable-tools-mac64arm.zip'
              : 'moddable-tools-mac64.zip'
            await downloadReleaseTools({
              writePath: BIN_PATH,
              assetName,
              release,
            })
          } else {
            throw error;
          }
        }
        const tools = filesystem.list(BIN_PATH) ?? []
        await Promise.all(
          tools.map(async (tool) => {
            if (tool.endsWith('.app')) {
              const mainPath = filesystem.resolve(
                BIN_PATH,
                tool,
                'Contents',
                'MacOS',
                'main'
              )
              await chmodPromise(mainPath, 0o751)
            } else {
              await chmodPromise(filesystem.resolve(BIN_PATH, tool), 0o751)
            }
            await filesystem.copyAsync(
              filesystem.resolve(BIN_PATH, tool),
              filesystem.resolve(DEBUG_BIN_PATH, tool)
            )
          })
        )
      }
      if (targetBranch === 'public') {
        spinner.start('Cloning Moddable-OpenSource/moddable repo')
        await system.spawn(
          `git clone ${MODDABLE_REPO} ${INSTALL_PATH} --depth 1 --branch ${targetBranch} --single-branch`
        )
      }
      spinner.succeed()
    } catch (error) {
      spinner.fail(`Error cloning moddable repo: ${String(error)}`)
      process.exit(1)
    }
  }

  // 2. configure MODDABLE env variable, add release binaries dir to PATH
  process.env.MODDABLE = INSTALL_PATH
  process.env.PATH = `${String(process.env.PATH)}:${BIN_PATH}`

  await upsert(PROFILE_PATH, `source ${EXPORTS_FILE_PATH}`)

  await upsert(EXPORTS_FILE_PATH, `export MODDABLE=${process.env.MODDABLE}`)
  await upsert(EXPORTS_FILE_PATH, `export PATH="${BIN_PATH}:$PATH"`)

  // 3. cd into makefiles dir for platform, run `make`
  if (targetBranch === 'public') {
    try {
      spinner.start('Building platform tooling')
      await system.exec('make', { cwd: BUILD_DIR, stdout: process.stdout })
      spinner.succeed()
    } catch (error) {
      spinner.fail(`Error building mac tooling: ${String(error)}`)
      process.exit(1)
    }
  }

  // 4. symlink xsbug.app into user applications directory
  try {
    filesystem.symlink(
      filesystem.resolve(BIN_PATH, 'xsbug.app'),
      '/Applications/xsbug.app'
    )
  } catch (error) {
    if (!String(error).includes('exists')) {
      spinner.fail(`Issue creating symlink for xsbug.app: ${String(error)}`)
      process.exit(1)
    } else {
      spinner.info('xsbug.app symlink already exists')
    }
  }

  // 5. install xsbug-log dependencies
  if (system.which('npm') !== null) {
    spinner.start('Installing xsbug-log dependencies')
    await system.exec('npm install', { cwd: XSBUG_LOG_PATH })
    spinner.succeed();
  }

  spinner.succeed(
    'Moddable SDK successfully set up! Start a new terminal session and run the "helloworld example": xs-dev run --example helloworld'
  )
}
